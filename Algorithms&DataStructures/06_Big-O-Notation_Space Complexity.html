<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 공간복잡성
    //  공간복잡도란 RAM을 사용하는 메모리의 양이다.
    //  코드의 양이 커지고 복잡해질 때 필요하다.

    //    시간복잡도 : 얼마나 많은 시간이 필요한가
    //    공간복잡도 : 얼마나 많은 메모리를 사용하게되는가

    // 공간복잡도의 규칙
    //  1. 변수선언은 늘 메모리를 소모한다.
    //      숫자나 Boolean의 경우 값이 크기가 작든 크든 같은양의 메모리를 소모한다. -> O(1)
    //      배열 문자열 객체의 경우 값의 크기에 따라 메모리의 양도 증가한다. -> O(n)

    // 예제1
    function shoutWhatsUpDawg(n){
      for(let i = 0; i < n; i++){
        console.log("what's up dawg?!");
      }
    }
    // 공간복잡도 O(1)
    // n의 값에 따라 변수선언된 i의 값이 증가하지만, 숫자는 크든 작든 같은 양의 메모리를 소모함

    // 예제2
    const sum = arr => {
      let total = 0;
      arr.forEach(num => {
        total += num
      });
      return total;
    }
    // 공간복잡도 O(1)
    // arr이라는 배열의 요소 값에 따라 내부 total의 값이 변경되지만, 마찬가지로 숫자는 크든 작든 같은 양의 메모리를 소모함.

    // 예제3
    const reverseString = str => {
      let reversedStr = "";
      for(let i = 0; i < str.length; i++){
        reversedStr = str[i] + reversedStr;
      }
      return reversedStr;
    }
    // 공간복잡도 O(n)
    // 입력되는 문자열 str 갯수에 따라 선언된 변수의 문자열 길이가 길어지고 있음.

    // 예제4
    const keepRandom = arr => {
      let resArr = [];
      arr.forEach(item => {
        if(Math.random() < 0.5) {
          resArr.push(item);
        }
      });
      return resArr;
    }
    // 공간복잡도 O(n)
    // 입력되는 배열인 arr의 절반의 확률로만 배열에 담는다고 하여 O(n/2) 같지만, Big-O 표기법에 따라 그냥 O(n)이다.

    // 공간복잡성보다 시간복잡성이 더 우선시되는 이유
    //  1. 비용이 더 높다
  </script>
</body>
</html>