<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // https://medium.com/@hyunwoojo/javascript-symbol-%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-6aa5903fb6f1
    // 7번째 원시 데이터 타입으로 추가된 Symbol
    // 객체의 고유 속성(key, value)을 만들수 있는 원시데이터 형식이다.
    // 객체에서 Symbol로 생성된 속성은, for of나 Object.keys등의 순회 method에서 노출되지 않는다.
    // Symbol은 string.replace, string.search등의 메소드를 사용할 수 있다.
    
    console.dir(Symbol) // Symbol은 함수이다.

    // Symbol을 생성하는 3가지 방법
    // 1. Symbol('원하는 key');
    //    고유한 Symbol(지역Symbol) 반환
    // 2. Symbol.for();
    // 3. Symbol.iterator

    // 1. Symbol('원하는 key')
    const mainDivide = Symbol('대분류');
    const subDivide = Symbol('소분류');
    const item = {};
    item[mainDivide] = '신선' // Symbol 선언법
    item[subDivide] = '고기'

    console.log(mainDivide); // Symbol(대분류)
    console.log(mainDivide === 'Symbol(대분류)'); // 결과값이 문자열처럼보이지만, 문자열도 아니고, == 도 성립안됨. 야예 다른 값
    console.log(Symbol('대분류') === Symbol('대분류')) // false
    console.log(item[mainDivide]); // 신선
    console.log(typeof mainDivide); // symbol
    // 문자열타입이 아니기 떄문에, 문자열과 합치는것이 불가능하다.
    console.log(item)

    // symbol.for? symbol.iterator?
    // Symbol.for();는 다른곳에서도 접근 가능한 Symbol을 생성하는것.
    // Symbol의 중요 특징인 고유성을 없애기 때문에, 되도록사용하지 말자.

    // iterable & Symbol.iterator
    // https://medium.com/@hyunwoojo/javascript-iterator-iterable-%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-2c6a7bb42d87
    // 비교
    // https://ko.javascript.info/iterable
    const obj = {
      1 : 'one',
      2 : 'two',
      3 : 'three'
    }
    // for(let a of obj){
    //   console.log(a) // obj is not iterable
    // }
    // console.log(...obj) // error
    // 현재 obj는 반복순회할 수 없기 때문에 위의 에러가 발생한다.
    // 해결하기 위해, 반복할 수 있는 Array의 형식으로 바꾸기위해 Object.keys 혹은 Object.values로 변환해줘야 한다.
    // 위처럼 Object method를 활용하여 새롭게 배열을 만드는것이 아닌, Symbol.iterator로 할 수 있다.

    const ChangeToIterable = (unIterableObj) => {
      const length = unIterableObj.length; // 필요없는거같은데?
      const iter = valuesIter(unIterableObj);
      // console.log(iter); // 1,2,3이 아닌 valuesIter 객체가 반환됨. generator학습후 확인해야할듯
      return { // iterator객체
        [Symbol.iterator] : function(){
          return this; // iterator객체를 반환함
        },
        next : function(){
          // console.log(iter.next()); // two는 객체반환 왜 안될까?
          return iter.next();
        }
      }
    };

    const valuesIter = function*(unIterableObj){
      for(let key in unIterableObj){
        // console.log(key) // 1,2,3
        yield unIterableObj[key];
      }
    };

    // 정상작동됨.
    for(let a of ChangeToIterable(obj)){
      console.log(a)
    };
    // console.log(...ChangeToIterable(obj));

    // generator 학습후 다시확인
    // https://medium.com/@hyunwoojo/javascript-generator-%EC%97%90-%EB%8C%80%ED%95%B4%EC%97%AC-52bdd790cd6b
  </script>
</body>
</html>