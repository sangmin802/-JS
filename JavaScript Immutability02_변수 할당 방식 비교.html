<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // var p1 = 1;
        // var p2 = 1;
        // console.log(p1 === p2);
        // var o1 = {name : 'kim'};
        // var o2 = {name : 'kim'};
        // console.log(o1 === o2);
    </script>
    <h2>객체의 복사</h2>
    <div>var o2 = o1처럼 객체를 복사하게될 경우, 같은 객체를 보게되면서, o2를 수정하게되면 o1의 내용도 같이바뀌게 된다. 이것을 막기위한 방법은?</div>
    <h5>Object.assign({}, 객체)</h5>
    <script>
        var o1 = {name:'kim'};
        var o2 = Object.assign({}, o1); // 첫번쨰인자와 두번째인자를 합쳐라
        o2.name = 'lee';
        console.log(o1);
        console.log(o2);
    </script>
    <h2>중첩된 객체의 복사(Nested object)</h2>
    <div>객체의 속성들이 모두 string, boolean, null등의 원시데이터라면 문제가 없겠지만, 속성이 객체형식(object, array)이라면(메소드는 아님) Object.assign을 했을 때, 이름은 복사가 되지만, 값들은 같은것을 바라보게된다(복사가 아닌 참조가 됨). 그럴 때에는, 객체구성의 속성들만 따로, 객체.속성 = 객체.속성.concat(원하는값)을 해주면 된다.</div>
    <script>
        var o3 = {
            name : 'kim',
            score : [1,2],
            add : function(){
                return this.score[0]+this.score[1];
            }
        }
        var o4 = Object.assign({}, o3);
        // o4.score.push(3);
        // console.log(o3.score)
        // console.log(o4.score)
        o4.score = o4.score.concat(3);
        // o4.score = o4.score.concat(); 하고 따로 push해줘도 됨
        o4.add = function(){
            return (this.score[0]+1)+this.score[1];
        }
        console.log(o3)
        console.log(o4)
    </script>
</body>
</html>